#ifndef SCAN_IO_H
#define SCAN_IO_H

#include <iostream>
#include "scanner_l/happly.h"
#include "scanner_l/type.h"
#include <opencv2/opencv.hpp>
#include "glog/logging.h"
#include <fstream>
#include <filesystem>
#include <string>
#include <stdio.h>
#include <stdlib.h>


/**
 * @brief 把点云数据写入 PLY 文件 (ASCII or BINARY).
 *
 * @param points 待写入的点云 (每个点必须含有可以转为 double 类型的成员 x, y, z)
 * @param num_points 点数
 * @param filename ply 文件名
 * @param colors (optional) 待写入的颜色, 默认为空
 * @param num_colors (optional) 待写入的颜色, 默认为 0
 * @param encoder (optional) 待写入的 encoder, 默认为空
 * @param num_encoder (optional) 待写入的 encoder, 默认为 0
 * @param frame (optional) 待写入的 frame, 默认为空
 * @param num_frame (optional) 待写入的 frame, 默认为 0
 * @param gray (optional) 待写入的 gray, 默认为空
 * @param num_gray (optional) 待写入的 gray, 默认为 0
 * @param comments (optional) 待写入的 comments, 默认为空
 * @param format (optional) 待写入的文件格式, 默认为 BINARY
 * @param encoderName (optional) encoder 的 key 名称, 默认为 "encoder"
 * @param frameName (optional) frame 的 key 名称, 默认为 "frame"
 * @param grayName (optional) gray 的 key 名称, 默认为 "gray"
 * @return true 写入成功
 * @return false 写入失败
 * @see [HapPLY](https://github.com/nmwsharp/happly?tab=readme-ov-file)
 * @see [PLY 文件格式](https://paulbourke.net/dataformats/ply/)
 */

template <typename T> 
bool WritePCToPLY(
    const T* points, int num_points, const std::string& filename, const cv::Vec3b* colors = nullptr,
    int num_colors = 0, const int* encoder = nullptr, int num_encoder = 0,
    const unsigned int* frame = nullptr, int num_frame = 0, const uint8_t* gray = nullptr,
    int num_gray = 0, const std::vector<std::string>& comments = {},
    const m_PlyFormat& format = m_PlyFormat::BINARY, const std::string& encoderName = "encoder",
    const std::string& frameName = "framecnt", const std::string& grayName = "intensity",
    bool filter_invalid_z = true) {

    size_t num_valid = num_points;
    std::vector<bool> valid_flags(num_points, true);
    for (size_t i = 0; i < num_points; i++) {
        if (filter_invalid_z && (points[i].z == -999 || points[i].z == -998 || points[i].z == -997)) {
            valid_flags[i] = false;
            num_valid--;
        }
    }
    try {
        happly::PLYData ply_out;
        if (!ply_out.hasElement("vertex")) {
            ply_out.addElement("vertex", num_valid);
        }

        ply_out.comments = {"Point cloud generated by AIEveR DepthSight L-Series 3D Profiler",
                            std::string("Datetime: ") + __DATE__ + " " + __TIME__,
                            "Invalid z value = -999, -998 or -997 with different meanings"};
        ply_out.comments.insert(ply_out.comments.end(), comments.begin(), comments.end());

        // ply_out.addVertexPositions(mesh_vertex_positions, num_valid, valid_flags);
        ply_out.getElement("vertex").addPropertyXYZ<T>(points, num_points, num_valid, valid_flags);
        //ply_out.getElement("vertex").addPropertyXYZ(points, num_points, num_valid, valid_flags);
        if (num_gray == num_points) {
            ply_out.getElement("vertex").addProperty<uint8_t>(grayName, gray, num_points, num_valid,
                                                              valid_flags);
        }
        if (num_encoder == num_points) {
            ply_out.getElement("vertex").addProperty<int>(encoderName, encoder, num_points,
                                                          num_valid, valid_flags);
        }
        if (num_frame == num_points) {
            ply_out.getElement("vertex").addProperty<unsigned int>(frameName, frame, num_points,
                                                                   num_valid, valid_flags);
        }

        if (num_colors == num_points) {
            std::vector<std::array<unsigned char, 3>> mesh_vertex_colors(num_colors);
            for (size_t i = 0; i < num_colors; i++) {
                mesh_vertex_colors[i][0] = colors[i][0];
                mesh_vertex_colors[i][1] = colors[i][1];
                mesh_vertex_colors[i][2] = colors[i][2];
            }
            ply_out.addVertexColors(mesh_vertex_colors, num_valid, valid_flags);
        }

        // Write the object to file
        switch (format) {
            case m_PlyFormat::ASCII: {
                ply_out.write(filename, happly::DataFormat::ASCII);
                break;
            }
            case m_PlyFormat::BINARY: {
                ply_out.write(filename, happly::DataFormat::Binary);
                break;
            }
        }
    } catch (const std::exception& e) {
        LOG(ERROR) << "Error writing ply file: " << filename << " with error: " << e.what() << "\n";
        // LOG_ERROR("Error writing ply file: %s with error: %s", filename.c_str(), e.what());
        return false;
    }

    std::ifstream file_exist(filename.c_str());
    if (!file_exist.good()) {
        LOG(ERROR) << "Existence checking failed: " << filename << "\n";
        return false;
    }

    LOG(ERROR) << num_valid << " points written to " << filename << "\n";
    // LOG_INFO("%zu points written to %s", num_valid, filename.c_str());
    return true;
}

#endif